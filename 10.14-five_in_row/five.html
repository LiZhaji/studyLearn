<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>five in row</title>
    <link rel="stylesheet" href="five.css" />
    <!-- <style>
    @import url(./five.css);
    </style> -->
  </head>
  <body>
    <!-- <s>ssss</s>
  <del>dellll</del>  -->
    <div class="rela">
      <canvas id="rows" width="800" height="800"></canvas>
      <div id="tools">
        <p>黑方: <span id="blackWins"></span></p>
        <p>白方: <span id="whiteWins"></span></p>
        <p><button data-reop="1" class="btn">重开一局</button></p>
        <p><button data-reop="2" class="btn">重新选择</button></p>
      </div>
    </div>

    <div id="playSelect" class="dialog">
      <div class="box">
        <p class="title">请选择游戏类型：</p>
        <p class="around">
          <button data-play="0" class="btn">和电脑玩</button>
          <button data-play="1" class="btn">我有俩人</button>
        </p>
      </div>
    </div>
    <div id="playAgain" class="dialog">
      <div class="box">
        <p id="winerTitle" class="title"></p>
        <p class="around">
          <button id="keepGoing" class="btn">继续</button>
        </p>
      </div>
    </div>
    <script>
      // TODO
      // wins的数量

      // 可修改变量
      const rows = {
        rowNum: 16,
        sideL: 50,
        pieceR: 15,
        validR: 15 // 点击的有效范围
      };
      const boardSideL = rows.rowNum * rows.sideL;

      const cv = document.querySelector("#rows");
      const ctx = cv.getContext("2d");

      const playSelectDia = document.querySelector("#playSelect");
      const playAgainDia = document.querySelector("#playAgain");
      const msgP = document.querySelector("#winerTitle");

      const blackWins = document.querySelector("#blackWins");
      const whiteWins = document.querySelector("#whiteWins");

      const dirs = ["lup", "up", "rup", "l", "r", "lbt", "bt", "rbt"];
      const dirOprs = {
        lup: [-1, -1],
        up: [0, -1],
        rup: [1, -1],
        l: [-1, 0],
        r: [1, 0],
        lbt: [-1, 1],
        bt: [0, 1],
        rbt: [1, 1]
      };
      const result = {
        black: 0,
        white: 0
      };
      let piecesCount = []; // 棋盘棋子情况
      let process = {}; // 棋子每个方向的自身个数
      let playStyle = "";
      let blackTime = true;
      let gameover = false;
      let blackSuc = true;

      // 绑定所有按钮的事件监听
      bindEvent();

      function bindEvent() {
        // 选择游戏
        playSelectDia.addEventListener("click", initGame);

        // 一局结束后 新一局游戏
        const keepGoing = document.querySelector("#keepGoing");
        keepGoing.addEventListener("click", () => {
          initBoard();
          playAgainDia.style.display = "none";
        });

        // 新一局游戏 或 重新选择游戏
        const tools = document.querySelector("#tools");
        tools.addEventListener("click", e => {
          const opt = e.target.dataset.reop || "";
          if (!opt) {
            return;
          }
          opt === "1" ? initBoard() : (playSelectDia.style.display = "flex");
        });
      }

      // 初始化游戏，重新选择
      function initGame(e) {
        playSelectDia.style.display = "flex";

        const playN = e.target.dataset.play || "";
        if (!playN) {
          return;
        }
        playStyle = playN;

        result.black = 0;
        result.white = 0;
        changeResult(result.black, result.white);

        initBoard();
        playSelectDia.style.display = "none";
      }

      // 初始化棋盘
      function initBoard() {
        cv.removeEventListener("click", handleDown);

        process = {};
        blackTime = true;
        gameover = false;
        piecesCount = [];
        for (let i = 0; i <= rows.rowNum; i++) {
          const row = [];
          for (let j = 0; j <= rows.rowNum; j++) {
            row.push(0);
          }
          piecesCount.push(row);
        }

        ctx.clearRect(0, 0, boardSideL, boardSideL);
        printBoard();

        // 根据选择的游戏类型进行下棋函数初始化
        downWhite = downFnInit().downWhite;
        downAuto = downFnInit().downAuto;

        cv.addEventListener("click", handleDown);
      }

      function downFnInit() {
        // 0：跟电脑下  1：都用户下
        if (playStyle === "0") {
          return {
            downWhite: async () => {
              let x = 0;
              let y = 0;

              const dangerP = {
                x: 0,
                y: 0,
                length: 0,
                totL: 0,
                dir: ""
              };
              // 找到最具危险性的黑棋
              for (const p in process) {
                if (p[0] === "1") {
                  const pDirs = process[p];
                  const i = +p.match(/(?<=_x).*(?=_y)/)[0];
                  const j = +p.match(/(?<=_y).*/)[0];
                  let totL = 0;
                  for (const dir in pDirs) {
                    const index = dirs.findIndex(d => d === dir);
                    const revDir = dirs[dirs.length - index - 1];

                    hasP = false || pDirs[revDir] === 1;
                    totL += pDirs[dir];
                    console.log(hasP, dir, pDirs[dir]);

                    if (
                      hasP &&
                      (pDirs[dir] > dangerP.length ||
                        (pDirs[dir] === dangerP.length && totL > dangerP.totL))
                    ) {
                      dangerP.length = pDirs[dir];
                      dangerP.x = i;
                      dangerP.y = j;
                      dangerP.totL = totL;
                      dangerP.dir = dir;
                      console.log(dangerP);
                    }
                  }
                }
              }

              if (dangerP.length <= 2) {
                let k = Math.floor(Math.random() * 8);
                let dir = dirs[k];
                let xx = dirOprs[dir][0];
                let yy = dirOprs[dir][1];
                while (piecesCount[dangerP.x + xx][dangerP.y + yy]) {
                  k = Math.floor(Math.random() * 8);
                  dir = dirs[k];
                  xx = dirOprs[dir][0];
                  yy = dirOprs[dir][1];
                }
                x = dangerP.x + xx;
                y = dangerP.y + yy;
              } else {
                const index = dirs.findIndex(d => d === dangerP.dir);
                const revDir = dirs[dirs.length - index - 1];
                const ii = dirOprs[revDir][0];
                const jj = dirOprs[revDir][1];

                x = dangerP.x + ii;
                y = dangerP.y + jj;
              }

              // 随机下
              // x = Math.ceil(Math.random() * (rows.rowNum - 2));
              // y = Math.ceil(Math.random() * (rows.rowNum - 2));
              // while (piecesCount[x][y]) {
              //   x = Math.ceil(Math.random() * (rows.rowNum - 2));
              //   y = Math.ceil(Math.random() * (rows.rowNum - 2));
              // }
              await printPiece(x * 50, y * 50, "wheat");
              piecesCount[x][y] = 2;
              blackTime = true;

              if (ifSuccess(x, y)) {
                return;
              }
            },
            downAuto: async (x, y, pieceX, pieceY) => {
              await downBlack(x, y, pieceX, pieceY);
              gameover ? "" : downWhite();
            }
          };
        } else if (playStyle === "1") {
          return {
            downWhite: async (x, y, pieceX, pieceY) => {
              await printPiece(pieceX, pieceY, "wheat");
              piecesCount[x][y] = 2;
              blackTime = true;

              if (ifSuccess(x, y)) {
                return;
              }
            },
            downAuto: (x, y, pieceX, pieceY) => {
              blackTime
                ? downBlack(x, y, pieceX, pieceY)
                : downWhite(x, y, pieceX, pieceY);
            }
          };
        }
      }

      function printBoard() {
        ctx.strokeRect(0, 0, boardSideL, boardSideL);
        for (let i = 0; i <= rows.rowNum; i++) {
          for (let j = 0; j <= rows.rowNum; j++) {
            ctx.strokeRect(
              i * rows.sideL,
              j * rows.sideL,
              rows.sideL,
              rows.sideL
            );
          }
        }
      }

      // 生成一颗棋子
      function printPiece(x, y, color) {
        return new Promise(r => {
          ctx.beginPath();
          ctx.moveTo(x + rows.pieceR, y);
          ctx.arc(x, y, rows.pieceR, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.closePath();
          console.log("print piece!");

          r();
        });
      }

      // 处理用户点击棋盘事件
      function handleDown(e) {
        if (gameover) {
          return;
        }
        // 最外层点击无效，判断为越界
        const crossX =
          e.offsetX < rows.sideL / 2 ||
          e.offsetX > rows.sideL * (rows.rowNum - 0.5);
        const crossY =
          e.offsetY < rows.sideL / 2 ||
          e.offsetY > rows.sideL * (rows.rowNum - 0.5);
        if (crossX || crossY) {
          console.log("越界了！");
          return;
        }

        // 对应的二维位置
        const x = Math.round(e.offsetX / rows.sideL);
        const y = Math.round(e.offsetY / rows.sideL);
        if (piecesCount[x][y]) {
          console.log("重复点击！");
          return;
        }

        // 对应的canvas的位置
        const focusX = x * rows.sideL;
        const focusY = y * rows.sideL;

        // 点击位置距离圆心位置的长度
        const distanceX = crossX ? Infinity : Math.abs(e.offsetX - focusX);
        const distanceY = crossY ? Infinity : Math.abs(e.offsetY - focusY);

        // 根据长度判断点击是否有效，确定棋子的圆心
        const pieceX = distanceX <= rows.validR ? focusX : -1;
        const pieceY = distanceY <= rows.validR ? focusY : -1;
        if (pieceX === -1 || pieceY === -1) {
          console.log("无效点击！");
          return;
        }

        downAuto(x, y, pieceX, pieceY);
      }

      // 是否需要自动化下白棋, 由 playN (游戏类型)决定，在 initGame() 中
      function downAuto() {}

      // 如何下白棋, 同上
      function downWhite() {}

      // 下黑棋
      async function downBlack(x, y, pieceX, pieceY) {
        await printPiece(pieceX, pieceY, "black");
        piecesCount[x][y] = 1;
        blackTime = false;

        return new Promise(r => {
          ifSuccess(x, y);
          r();
        });
      }

      // 是否获胜
      function ifSuccess(x, y) {
        if (success(x, y)) {
          let msg = "";
          if (gameover && blackSuc) {
            msg = "black wins!";
            result.black += 1;
          } else if (gameover && !blackSuc) {
            msg = "white wins!";
            result.white += 1;
          }
          msgP.innerText = msg;
          playAgainDia.style.display = "flex";
          console.log(result);

          changeResult(result.black, result.white);
          return true;
        }
        return false;
      }

      // 获胜
      function success(i, j) {
        const curPiece = piecesCount[i][j]; // 当前位置 0: 空, 1: 黑棋, 2: 白棋
        const key = "" + curPiece + "_x" + i + "_y" + j;
        process[key] = process[key] || {};
        const dirs = process[key];
        const tempDir = ["lup", "up", "rup", "l", "r", "lbt", "bt", "rbt"];

        // 按照tempDir的顺序 计算该棋子每个方向的相同棋子数
        for (let jj = j - 1; jj <= j + 1; jj++) {
          for (let ii = i - 1; ii <= i + 1; ii++) {
            if (gameover) {
              return true;
            }

            // 该位置本身不参与记录
            if (jj === j && ii === i) {
              continue;
            }
            const curDir = tempDir.shift();
            // 表示该方向越界了
            if (jj < 0 || ii < 0 || jj > rows.rowNum || ii > rows.rowNum) {
              dirs[curDir] = -1;
              continue;
            }

            dirs[curDir] = getDirCount(ii, jj, curDir, curPiece);
          }
        }
        process[key] = dirs;
        console.log(piecesCount, process);

        return false;
      }

      function getDirCount(i, j, curDir, curPiece) {
        const targetPiece = piecesCount[i][j]; // 该方向上的第一个棋子
        const index = dirs.findIndex(dir => dir === curDir);
        const revDir = dirs[dirs.length - index - 1];
        let tarCount = 1;

        // 如果第一颗棋子为空，返回1，表示只有它本身
        if (!targetPiece) {
          return tarCount;
        } else if (targetPiece === curPiece) {
          // 1. 目标count = 当前count + 1
          const ii = dirOprs[curDir][0];
          const jj = dirOprs[curDir][1];
          const curCount =
            process["" + targetPiece + "_x" + i + "_y" + j][curDir] > 0
              ? process["" + targetPiece + "_x" + i + "_y" + j][curDir]
              : 1; // 小于0表示没有一样的棋子，不能用该值参与计算
          tarCount = curCount + 1;

          // 2. 当前方向上所有的棋子反方向的count 更新
          // 需判断新棋子的反方向有无自家棋子,有则需要全部重新赋值
          const revCount =
            process["" + targetPiece + "_x" + (i - ii) + "_y" + (j - jj)][
              revDir
            ] > 1 // 大于1表示有
              ? process["" + targetPiece + "_x" + (i - ii) + "_y" + (j - jj)][
                  revDir
                ]
              : 1;
          for (let k = 0; k < curCount; k++) {
            process[
              "" + targetPiece + "_x" + (i + ii * k) + "_y" + (j + jj * k)
            ][revDir] += revCount;
          }

          // 11011,修改这种情况的bug
          if (revCount > 1) {
            for (let k = 2; k <= revCount; k++) {
              let rp = (process[
                "" + targetPiece + "_x" + (i - ii * k) + "_y" + (j - jj * k)
              ][curDir] += tarCount - 1); // 减去新棋的重复
              if (rp >= 5) {
                gameover = true;
                blackSuc = curPiece === 1 ? true : false;
                return;
              }
            }
          }
        } else {
          // 表示第一颗棋为对方棋子, 不仅要返回-2, 还要设置对方棋反方向的count = -2
          tarCount = -2;
          process["" + targetPiece + "_x" + i + "_y" + j][revDir] = -2;
          return tarCount;
        }
        if (tarCount >= 5) {
          gameover = true;
          blackSuc = curPiece === 1 ? true : false;
        }
        return tarCount;
      }

      function changeResult(bl, wh) {
        blackWins.innerText = result.black;
        whiteWins.innerText = result.white;
      }
    </script>
  </body>
</html>

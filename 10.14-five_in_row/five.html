<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>five in row</title>
    <style>
      .rela {
        position: relative;
      }
    </style>
  </head>
  <body>
    <!-- <ul>
    <li>x</li>
    <li>x</li>
    <li>x</li>
  </ul>
  <ol>
    <li>y</li>
    <li>y</li>
    <li>y</li>
  </ol>
  <s>ssss</s>
  <del>dellll</del> -->
    <div class="rela">
      <canvas id="rows" width="500" height="500"></canvas>
    </div>
    <script>
      const cv = document.querySelector("#rows");
      const ctx = cv.getContext("2d");
      const rows = {
        rowNum: 10,
        sideL: 50,
        pieceR: 15,
        validR: 15 // 点击的有效范围
      };
      const dirs = ['lup', 'up', 'rup', 'l', 'r', 'lbt', 'bt', 'rbt']
      const dirOprs = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
      let piecesCount = []
      let process = {}
      let msg = ''
      let touristTime = true;
      let over = false

      init()

      function init() {
        piecesCount = []
        for (let i = 0; i < rows.rowNum; i++) {
          const row = []
          for (let j = 0; j < rows.rowNum; j++) {
            row.push(0)
          }
          piecesCount.push(row)
        }
        process = {}
        ctx.clearRect(0, 0, rows.rowNum * rows.sideL, rows.rowNum * rows.sideL)
        pirntRows();
        touristTime = true
        over = false
        downByTourist();
      }

      function pirntRows() {
        ctx.strokeRect(0, 0, rows.rowNum * rows.sideL, rows.rowNum * rows.sideL);
        for (let i = 0; i <= rows.rowNum; i++) {
          for (let j = 0; j <= rows.rowNum; j++) {
            ctx.strokeRect(
              i * rows.sideL,
              j * rows.sideL,
              rows.sideL,
              rows.sideL
            );
          }
        }
      }

      // 画棋子
      function printPiece(x, y, color) {
        ctx.beginPath()
        ctx.moveTo(x + rows.pieceR, y);
        ctx.arc(x, y, rows.pieceR, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill()
        ctx.closePath()
      }

      // 游客下黑棋
      function downByTourist(params) {
        cv.addEventListener("click", e => {
          if (!touristTime || over) {
            return;
          }
          const crossX = e.offsetX < rows.sideL / 2 || e.offsetX > rows.sideL * (rows.rowNum - 0.5);
          const crossY = e.offsetY < rows.sideL / 2 || e.offsetY > rows.sideL * (rows.rowNum - 0.5);
          if (crossX || crossY) {
            console.log("越界了！");
            return;
          }
          const x = Math.round(e.offsetX / 50);
          const y = Math.round(e.offsetY / 50);
          if(piecesCount[x][y]){
            console.log(piecesCount);
            
            console.log("重复点击！");
            return;
          }
          const focusX = x * 50;
          const focusY = y * 50;
          const distanceX = crossX ? Infinity : Math.abs(e.offsetX - focusX);
          const distanceY = crossY ? Infinity : Math.abs(e.offsetY - focusY);
          const pieceX = distanceX <= rows.validR ? focusX : -1;
          const pieceY = distanceY <= rows.validR ? focusY : -1;
          if (pieceX === -1 || pieceY === -1) {
            console.log("无效点击！");
            return
          }
          
          printPiece(pieceX, pieceY, "black");
          piecesCount[x][y] = 1
          
          if(success(x, y)){
            alert(msg)
            init()
            return
          } 
          
          touristTime = false;
          downByComputer()


        });
      }

      // 电脑下白棋
      function downByComputer() {
        if (touristTime || over) {
          return
        }
        // 随机下
        let x = Math.ceil( Math.random() *  (rows.rowNum - 2))
        let y = Math.ceil( Math.random() *  (rows.rowNum - 2))
        while(piecesCount[x][y]){
          x = Math.ceil( Math.random() *  (rows.rowNum - 2))
          y = Math.ceil( Math.random() *  (rows.rowNum - 2))
        }
        printPiece(x * 50, y * 50, 'wheat')
        piecesCount[x][y] = 2
        touristTime = true;

        success(x, y)

      }

      // 成功
      function success(i, j) {
        const curPiece = piecesCount[i][j]
        const key = '' + i + j
        process[key] = process[key] || {}
        const dirs = process[key]
        const tempDir = ['lup', 'up', 'rup', 'l', 'r', 'lbt', 'bt', 'rbt']
        for (let jj = j-1; jj <= j+1; jj++) {
          for (let ii = i-1; ii <= i+1; ii++) {
            // 该点本身不参与记录
            if (jj === j && ii === i) {
              continue
            }
            const curDir = tempDir.shift()
            // 表示该方向越界了
            if (jj < 0 || ii < 0) {
              dirs[curDir] = -1 
              continue
            }

            dirs[curDir] = getDirCount(ii, jj, curDir, curPiece)
            
          }
        }
        process[key] = dirs
        console.log(key, process[key]);
        if (over) {
          return true
        }
        return false
        
      }

      function getDirCount(i, j, curDir, curPiece) {
        let curCount = 1
        console.log(i , j);
        
        const targetPiece = piecesCount[i][j]

        if (!targetPiece) {
          return curCount
        }else if (targetPiece === curPiece) {
          const index = dirs.findIndex(dir => dir === curDir)
          const ii = dirOprs[index][0]
          const jj = dirOprs[index][1]
        console.log(ii , jj, piecesCount);

          // 得到当前方向自己的count = 前一个count + 1
          curCount = getDirCount(i + ii, j + jj, curDir, targetPiece) + 1

          // 当前方向上所有的棋子反方向的count +  1
          const revDir = dirs[dirs.length - index]
          process['' + i +j][revDir] = getDirCount(i + ii, j + jj, curDir, targetPiece) + 1
        }else {
          // 表示为对方棋子
          curCount = -2 
          return curCount
        }
        if (curCount >= 5) {
          over = true
          msg = curPiece === 1 ? 'you win!' :  
                curPiece === 2 ? 'computer wins!' : ''
        }
        return curCount
      }

    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>five in row</title>
    <style>
      body {
        position: absolute;
      }
      .rela {
        position: relative;
      }
      .dialog {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        background: #80808087;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .box {
        width: 200px;
        background: #f3f2f2;
        padding: 20px;
        border-radius: 5px;
        border: 1px solid;
        text-align: center;
      }
      .title {
        font-size: 25px;
      }
      .around {
        display: flex;
        justify-content: space-around;
      }
      .btn {
        background: linear-gradient(#f0f0f0, #f0f0f0, #c5bcbc, #f0f0f0);
        border: 1px solid #a09d9d;
        border-radius: 2px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 13px;
        outline: none;
      }
      .btn:hover {
        font-size: 14px;
        background: linear-gradient(#f0f0f0, #c2b6b6, #f0f0f0);
      }
    </style>
  </head>
  <body>
    <!-- <s>ssss</s>
  <del>dellll</del>  -->
    <div class="rela">
      <canvas id="rows" width="800" height="800"></canvas>
    </div>
    <div id="playSelect" class="dialog">
      <div class="box">
        <p class="title">请选择游戏类型：</p>
        <p class="around">
          <button data-play="0" class="btn play_style">和电脑玩</button>
          <button data-play="1" class="btn play_style">我有俩人</button>
        </p>
      </div>
    </div>
    <div>

    </div>

    <script>

      const rows = {
        rowNum: 16,
        sideL: 50,
        pieceR: 15,
        validR: 15 // 点击的有效范围
      };

      const cv = document.querySelector("#rows");
      const ctx = cv.getContext("2d");
      const msgP = document.querySelector(".title");
      const playDialog = document.querySelector("#playSelect");
      const boardSideL = rows.rowNum * rows.sideL;
      const dirs = ["lup", "up", "rup", "l", "r", "lbt", "bt", "rbt"];
      const dirOprs = [
        [-1, -1],
        [0, -1],
        [1, -1],
        [-1, 0],
        [1, 0],
        [-1, 1],
        [0, 1],
        [1, 1]
      ];
      const result = {};
      let piecesCount = []; // 棋盘棋子情况
      let process = {}; // 棋子每个方向的自身个数
      let msg = "";
      let playStyle = "";
      let blackTime = true;
      let over = false;

      playSelect();

      function playSelect() {
        playDialog.addEventListener("click", e => {
          const playN = e.target.dataset.play || "";
          if (!playN) {
            return;
          }
          playStyle = playN;
          playDialog.style.display = "none";

          init();
        });
      }

      function init() {
        cv.removeEventListener("click", handleDown);

        process = {};
        msg = "";
        blackTime = true;
        over = false;
        piecesCount = [];
        for (let i = 0; i <= rows.rowNum; i++) {
          const row = [];
          for (let j = 0; j <= rows.rowNum; j++) {
            row.push(0);
          }
          piecesCount.push(row);
        }

        downWhite = downFnInit().downWhite;
        downAuto = downFnInit().downAuto;

        ctx.clearRect(0, 0, boardSideL, boardSideL);
        pirntRows();
        downByTourist();
      }

      function downFnInit() {
        if (playStyle === "0") {
          return {
            downWhite: async () => {
              // 随机下
              let x = Math.ceil(Math.random() * (rows.rowNum - 2));
              let y = Math.ceil(Math.random() * (rows.rowNum - 2));
              while (piecesCount[x][y]) {
                x = Math.ceil(Math.random() * (rows.rowNum - 2));
                y = Math.ceil(Math.random() * (rows.rowNum - 2));
              }
              await printPiece(x * 50, y * 50, "wheat");
              piecesCount[x][y] = 2;
              blackTime = true;

              if (ifSuccess(x, y)) {
                return;
              }
            },
            downAuto: (x, y, pieceX, pieceY) => {
              downBlack(x, y, pieceX, pieceY);
              downWhite();
            }
          };
        } else if (playStyle === "1") {
          return {
            downWhite: async (x, y, pieceX, pieceY) => {
              await printPiece(pieceX, pieceY, "wheat");
              piecesCount[x][y] = 2;
              blackTime = true;

              if (ifSuccess(x, y)) {
                return;
              }
            },
            downAuto: (x, y, pieceX, pieceY) => {
              blackTime
                ? downBlack(x, y, pieceX, pieceY)
                : downWhite(x, y, pieceX, pieceY);
            }
          };
        }
      }

      function pirntRows() {
        ctx.strokeRect(0, 0, boardSideL, boardSideL);
        for (let i = 0; i <= rows.rowNum; i++) {
          for (let j = 0; j <= rows.rowNum; j++) {
            ctx.strokeRect(
              i * rows.sideL,
              j * rows.sideL,
              rows.sideL,
              rows.sideL
            );
          }
        }
      }

      // 画棋子
      function printPiece(x, y, color) {
        return new Promise(r => {
          ctx.beginPath();
          ctx.moveTo(x + rows.pieceR, y);
          ctx.arc(x, y, rows.pieceR, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.closePath();
          console.log("print piece!");

          r();
        });
      }

      // 游客下棋
      function downByTourist() {
        cv.addEventListener("click", handleDown);
      }

      function handleDown(e) {
        if (over) {
          return;
        }
        const crossX =
          e.offsetX < rows.sideL / 2 ||
          e.offsetX > rows.sideL * (rows.rowNum - 0.5);
        const crossY =
          e.offsetY < rows.sideL / 2 ||
          e.offsetY > rows.sideL * (rows.rowNum - 0.5);
        if (crossX || crossY) {
          console.log("越界了！");
          return;
        }
        const x = Math.round(e.offsetX / 50);
        const y = Math.round(e.offsetY / 50);
        if (piecesCount[x][y]) {
          console.log(x, y, piecesCount[x][y], piecesCount);

          console.log("重复点击！");
          return;
        }
        const focusX = x * 50;
        const focusY = y * 50;
        const distanceX = crossX ? Infinity : Math.abs(e.offsetX - focusX);
        const distanceY = crossY ? Infinity : Math.abs(e.offsetY - focusY);
        const pieceX = distanceX <= rows.validR ? focusX : -1;
        const pieceY = distanceY <= rows.validR ? focusY : -1;
        if (pieceX === -1 || pieceY === -1) {
          console.log("无效点击！");
          return;
        }

        downAuto(x, y, pieceX, pieceY);
      }

      function downAuto() {}

      async function downBlack(x, y, pieceX, pieceY) {
        await printPiece(pieceX, pieceY, "black");
        piecesCount[x][y] = 1;
        blackTime = false;

        if (ifSuccess(x, y)) {
          return;
        }

      }

      // 下白棋
      function downWhite() {}

      // 是否获胜
      function ifSuccess(x, y) {
        if (success(x, y)) {
          msgP.innerText = msg;
          playDialog.style.display = "flex";
          init();
          return true;
        }
        return false;
      }

      // 获胜
      function success(i, j) {
        const curPiece = piecesCount[i][j];
        const key = "" + i + j;
        process[key] = process[key] || {};
        const dirs = process[key];
        const tempDir = ["lup", "up", "rup", "l", "r", "lbt", "bt", "rbt"];
        for (let jj = j - 1; jj <= j + 1; jj++) {
          for (let ii = i - 1; ii <= i + 1; ii++) {
            // 该点本身不参与记录
            if (jj === j && ii === i) {
              continue;
            }
            const curDir = tempDir.shift();
            // 表示该方向越界了
            if (jj < 0 || ii < 0 || jj > rows.rowNum || ii > rows.rowNum) {
              dirs[curDir] = -1;
              continue;
            }

            dirs[curDir] = getDirCount(ii, jj, curDir, curPiece);
          }
        }
        process[key] = dirs;
        console.log(piecesCount, process);
        if (over) {
          return true;
        }
        return false;
      }

      function getDirCount(i, j, curDir, curPiece) {
        const targetPiece = piecesCount[i][j];
        const index = dirs.findIndex(dir => dir === curDir);
        const revDir = dirs[dirs.length - index - 1];
        let tarCount = 1;

        if (!targetPiece) {
          return tarCount;
        } else if (targetPiece === curPiece) {
          // 目标count = 当前count + 1
          const ii = dirOprs[index][0];
          const jj = dirOprs[index][1];
          const curCount = process["" + i + j][curDir];
          tarCount = curCount + 1;

          // 当前方向上所有的棋子反方向的count + n
          // 新棋子的反方向有无自家棋子,有则需要重新赋值
          const revCount = process["" + (i - ii) + (j - jj)][revDir] > 1 ? process["" + (i - ii) + (j - jj)][revDir] : 1
          for (let k = 0; k < curCount; k++) {
            process["" + (i + ii * k) + (j + jj * k)][revDir] += revCount;
          }
          if (revCount > 1) {
            for (let k = 2; k <= revCount; k++) {
              let rp = process["" + (i - ii * k) + (j - jj * k)][curDir] += tarCount - 1 // 减去新棋的重复
              if (rp >= 5) {
                over = true;
                msg =
                  curPiece === 1
                    ? "balck wins!"
                    : curPiece === 2
                    ? "white wins!"
                    : "";
                curPiece === 1 ? (result.black += 1) : (result.white += 1);
                return
              }
            }
          }
          // process['' + i + j][revDir] = getDirCount(i + ii, j + jj, curDir, targetPiece) + 1
        } else {
          // 表示当前棋为对方棋子, 对方棋子的反方向count = -2
          tarCount = -2;
          process["" + i + j][revDir] = -2;
          return tarCount;
        }
        if (tarCount >= 5) {
          over = true;
          msg =
            curPiece === 1
              ? "balck wins!"
              : curPiece === 2
              ? "white wins!"
              : "";
          curPiece === 1 ? (result.black += 1) : (result.white += 1);
        }
        return tarCount;
      }
    </script>
  </body>
</html>
